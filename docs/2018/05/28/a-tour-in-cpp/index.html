<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/firefirer.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/firefirer.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/firefirer.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/firefirer.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/firefirer.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/firefirer.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/firefirer.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="A Tour in C++基本知识声明，类型，对象，变量，值 声明(declaration): 一条语句，为本文件引入一个新的名字  类型(type): 类型定义了一组可能的值，以及(此类型的对象上) 可以实施的操作 对象(object): 存放某类型值的内存空间 变量(variable): 已命名的对象 值(value): 一组二进制位，具体含义由其类型负责解释  变量初始化C++ 提供两种初始">
<meta property="og:type" content="article">
<meta property="og:title" content="A Tour in C++">
<meta property="og:url" content="https://github.com/firefirer1983/firefirer.github.io/2018/05/28/a-tour-in-cpp/index.html">
<meta property="og:site_name" content="On Fire">
<meta property="og:description" content="A Tour in C++基本知识声明，类型，对象，变量，值 声明(declaration): 一条语句，为本文件引入一个新的名字  类型(type): 类型定义了一组可能的值，以及(此类型的对象上) 可以实施的操作 对象(object): 存放某类型值的内存空间 变量(variable): 已命名的对象 值(value): 一组二进制位，具体含义由其类型负责解释  变量初始化C++ 提供两种初始">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-06-07T14:31:08.279Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="A Tour in C++">
<meta name="twitter:description" content="A Tour in C++基本知识声明，类型，对象，变量，值 声明(declaration): 一条语句，为本文件引入一个新的名字  类型(type): 类型定义了一组可能的值，以及(此类型的对象上) 可以实施的操作 对象(object): 存放某类型值的内存空间 变量(variable): 已命名的对象 值(value): 一组二进制位，具体含义由其类型负责解释  变量初始化C++ 提供两种初始">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/firefirer.github.io/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/firefirer1983/firefirer.github.io/2018/05/28/a-tour-in-cpp/"/>





  <title>A Tour in C++ | On Fire</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/firefirer.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">On Fire</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/firefirer.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/firefirer.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/firefirer1983/firefirer.github.io/firefirer.github.io/2018/05/28/a-tour-in-cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fyman.zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/firefirer.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="On Fire">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">A Tour in C++</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-28T09:45:06+08:00">
                2018-05-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="A-Tour-in-C"><a href="#A-Tour-in-C" class="headerlink" title="A Tour in C++"></a>A Tour in C++</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="声明，类型，对象，变量，值"><a href="#声明，类型，对象，变量，值" class="headerlink" title="声明，类型，对象，变量，值"></a>声明，类型，对象，变量，值</h3><ul>
<li>声明(declaration): 一条语句，为本文件引入一个新的名字 </li>
<li>类型(type): 类型定义了一组可能的值，以及(此类型的对象上) 可以实施的操作</li>
<li>对象(object): 存放某类型值的内存空间</li>
<li>变量(variable): 已命名的对象</li>
<li>值(value): 一组二进制位，具体含义由其类型负责解释</li>
</ul>
<h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><p>C++ 提供两种初始化的方式：</p>
<ol>
<li>“=”</li>
<li>{}: 这种方式是以花括号，将一个初始化值列表包括起来</li>
</ol>
<h3 id="作用域和生命周期："><a href="#作用域和生命周期：" class="headerlink" title="作用域和生命周期："></a>作用域和生命周期：</h3><p>声明语句把一个名字引入他的作用域中：</p>
<ul>
<li>局部作用域：域大小是由 {} 包括起来的块，函数参数也属于局部作用域。</li>
<li>类作用域：一个名字定义在类内部，同时位于任何函数，lambda，enum class的外部</li>
<li>命名空间作用域：如果一个名字定义在命名空间内部，同事位于任何函数，lambda，enum class的外部。</li>
<li>声明在上述所有的结构之外的名字为全局作用域</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li>const： 编译器负责确认并执行不变的承诺。</li>
<li>constexpr： “在编译时求值” 。 允许把数据置于只读内存中，以防被破坏，以及提升性能</li>
</ul>
<p>如果某个函数被用在常量表达式( const expression )中，该表达式在编译时求值，则这个函数必须定义为constexpr<br>例如：</p>
<pre><code>constexpr double square(double x) { return x*x; }
</code></pre><p>想要定义为constexpr，函数必须非常简单：函数中仅有一条计算某个值的return 语句。</p>
<h3 id="指针，数组，引用"><a href="#指针，数组，引用" class="headerlink" title="指针，数组，引用"></a>指针，数组，引用</h3><ul>
<li>xxx[]表示 xxx的数组</li>
<li>xxx* 表示 指向 xxx</li>
<li>xxx&amp; 表示 xxx的引用，一个引用初始化后不能再引用其他对象了。</li>
</ul>
<p>数组里的元素遍历的新方法 range-for：</p>
<pre><code>int v[]={0,1,2,3,4,5,6,7,8,9};
for(auto x:v)
  cout &lt;&lt; x &lt;&lt; endl;
</code></pre><p>如果我们不希望将v的值拷贝到变量x中，而只是让x引用一个元素：</p>
<pre><code>int v[]={0,1,2,3,4,5,6,7,8,9};
for(auto &amp;x:v)
  cout &lt;&lt; x &lt;&lt; endl;
</code></pre><p>func 通过把参数 r 类型定义为 int 引用，在调用 func(int &amp;r) 函数的时候就不必把实参拷贝给形参。<br>在调用 func(my_val) 的是，就直接在 my_val上执行操作。</p>
<p>如果既不想修改实参内容，由希望节省参数拷贝的的代价，可以用 const 引用</p>
<h2 id="用户自定义类型"><a href="#用户自定义类型" class="headerlink" title="用户自定义类型"></a>用户自定义类型</h2><h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p>由const，基本类型 (int, char, short , double) ，声明运算符([], * , &amp;) 三种构造出来的类型，称为内置类型(build-in type)</p>
<h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>由c++的抽象机制构建的新类型，称为用户自定义类型(user-defined type)，诸如 class 和 enum</p>
<h3 id="new-delete-操作符"><a href="#new-delete-操作符" class="headerlink" title="new / delete 操作符"></a>new / delete 操作符</h3><p>new 运算符从一块名为(动态内存 dynamic memory，或叫 堆 heap) 的区域中分配一段内存空间。分配的内存独立于它所在<br>的作用域，会一直” 存活 “到使用 delete运算符销毁它为止。</p>
<pre><code>int *m = new int;   // 从堆中分配大小为sizeof(int)的内存空间，并且将内存空间的地址值赋值给m
int *a = new int[10];// 从堆中分配大小为 10*sizeof(int)的内存空间，并且将其首个元素的内存地址值赋值给 a
int &amp;m = *(new int); // m 是从堆中分配大小为sizeof(int)的内存空间的引用
int &amp;a = *(new int[10]); // a 是从堆中分配的大小为 10*sizeof(int)大小空间的首个元素的引用
a = 5;
m = 5;
static_assert(sizeof(*(new int)) == sizeof(*(new int[10])), &quot;is the same&quot;);
</code></pre><h3 id="自定义类型-struct-class-enum-union"><a href="#自定义类型-struct-class-enum-union" class="headerlink" title="自定义类型 : struct/class , enum, union"></a>自定义类型 : struct/class , enum, union</h3><h4 id="类-class-struct-："><a href="#类-class-struct-：" class="headerlink" title="类 class/struct  ："></a>类 class/struct  ：</h4><p>与所属类同名的函数，称为 构造函数。构造函数是用来构造类对象的。</p>
<blockquote>
<p>类的目的构造一个功能模块，实现功能的 <strong> 接口 </strong> 和 <strong> 实现 </strong> 分离。<br>接口(代码可对外访问部分) : public<br>实现(代码不可对外访问部分，主要用于构造本功能) : private</p>
</blockquote>
<h4 id="联合-union"><a href="#联合-union" class="headerlink" title="联合 union"></a>联合 union</h4><p>union是一种特殊的struct，所有成员都被分配在同一块内存区域中。因此union所占的内存空间就是它最大成员所占的空间<br>而且，同一时刻 union只能保存一个成员的值</p>
<h4 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a>枚举 enum</h4><ol>
<li><p>裸的枚举类型</p>
<pre><code>enum {red, yellow, green
</code></pre></li>
<li><p>类中的枚举类型：</p>
<pre><code>enum class Color{red, yellow, green};
enum class TraficLigth{red, yellow, green};
</code></pre></li>
</ol>
<p>枚举值位于class的作用域内，就可以在不同的enum class中重复使用这些枚举值而不致引起混淆例如：</p>
<pre><code>Color x = Color::red;
Color y = TrafficLight::red;
</code></pre><p>默认情况下，enum class只定义了赋值，初始化 和比较( == 和 &lt; ) 操作，然而，既然枚举类型是一种用户自定义类型<br>那么我们就可以为它定义别的运算符：</p>
<pre><code>TrafficLight&amp; operator++(TrafficLight &amp;t) {
  switch(t){
  case TrafficLight::green: return t=TrafficLight::yellow;
  case TrafficLight::yellow: return t=TrafficLight::red;
  case TrafficLight::red: return t=TrafficLight::green;
  }
}

TrafficLight now = TrafficLight::red;
TrafficLight next = now ++; // next == TrafficLight::green
</code></pre><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ul>
<li>引言</li>
<li>分离编译</li>
<li>命名空间</li>
</ul>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>模块化的第一步是通过类来分离接口和实现，同时声明在<em>.h，定义在</em>.cpp</p>
<h3 id="分离编译"><a href="#分离编译" class="headerlink" title="分离编译"></a>分离编译</h3><p>用户代码(*.h)只可见类型和函数接口<br>头文件的作用是描述接口和强调逻辑结构的。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>命名空间机制，一方面表达某些声明式属于一个整体的，同时不会跟其他命名空间中的冲突。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>错误处理内容远超语言特性层面，而应归结为程序设计技术和工具范畴。</p>
<h4 id="异常-exception"><a href="#异常-exception" class="headerlink" title="异常(exception)"></a>异常(exception)</h4><p>功能的作者一般不知道出现异常的时候用户(使用者)希望怎么处理，同时用户(使用者)不能保证每次都能正确使用功能</p>
<blockquote>
<p>最佳的解决方案是由功能实现者负责检测，并且将异常情况通知使用者。</p>
</blockquote>
<p>throw负责把程序的控制权从异常发生处转移到异常处理代码。<br>为了实现这一目标，异常实现部分需要解开(unwind)函数调用栈以便返回主调用函数的上下文。<br>异常处理机制把程序的控制权从当前作用域转移到处理该类型错误的代码，<strong> 有必要的时候调用析构函数 </strong></p>
<p>把一个永远不会抛出异常的函数声明为noexcept，一旦真的发生错误，函数user还是会抛出异常，此时标准库函数<br>terminate()立即终止当前程序执行。</p>
<pre><code>void user(int sz) noexcept {
  std::vector(sz);
}
</code></pre><p>不变式</p>
<blockquote>
<p>对于类来说，一条假定某事为真的声明成为类的不变式(class invariant)，建立不变式是构造函数的任务，从而成员函数<br>可以依赖于该不变式，另一个作用是确保当前函数提出时不变式仍然成立。</p>
</blockquote>
<h4 id="静态断言"><a href="#静态断言" class="headerlink" title="静态断言"></a>静态断言</h4><p>异常和普通断言负责报告运行时错误，编译时错误可用静态断言来检查。</p>
<pre><code>static_assert(4&lt;=sizeof(int), &quot;integers size are too small&quot;);
</code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li>引言</li>
<li>具体类型</li>
<li>抽象类型</li>
<li>虚函数</li>
<li>类层次结构</li>
<li>拷贝和移动</li>
<li>建议</li>
</ul>
<p>C++ 最核心的语言特性就是类(class)，类有三种 ：</p>
<ol>
<li>具体类</li>
<li>抽象类</li>
<li>模板类</li>
<li>类层次结构中的类</li>
</ol>
<h3 id="具体类："><a href="#具体类：" class="headerlink" title="具体类："></a>具体类：</h3><ul>
<li>基本思想是它们的行为”就像内置类型一样”</li>
<li>有自己确定的语义和操作集合</li>
</ul>
<p>我们应该把简单的操作设置为内联的。也就是这些操作不应该以函数调用的方式实现。<br>** 定义在类内部的函数默认是内联的，我们也可以在函数声明前加上inline关键字，从而显示指定为内联。</p>
<p>默认构造函数：</p>
<blockquote>
<p>无需实参就可以调用的构造函数称为默认构造函数(default constructor)</p>
</blockquote>
<p>如果很多函数并不需要直接访问成员变量，可以将这些函数和类的定义分离。</p>
<h4 id="容器：是指一个包含若干元素的对象。"><a href="#容器：是指一个包含若干元素的对象。" class="headerlink" title="容器：是指一个包含若干元素的对象。"></a>容器：是指一个包含若干元素的对象。</h4><p>析构函数：</p>
<blockquote>
<p>一种以确保构造函数分配的内存一档会被销毁的机制。</p>
</blockquote>
<p>构造函数和析构函数的存在意义：</p>
<ol>
<li>一些值的初始化，可在构造函数内自动执行赋值行为。</li>
<li>当类内部的成员是在堆上分配(new)，那么在构造函数new，析构函数 delete实现资源自动申请和回收。(RAII)</li>
</ol>
<p>数据句柄模型(handle-to-data model): 用来管理在对象生命周期中大小会发生变化的数据。在构造函数中获取资源，<br>然后在西沟函数中释放，这种技术称为(RAII：Resource Acquisition Is Initialization)。</p>
<p>试想，如果一个类里面所有的成员都是从栈上分配内存空间的，那么默认就是RAII的。<br>但是当类有从堆上分配资源，那么就需要用RAII的技术更好的去管理资源。(避免手动调用new/delete，或者叫裸new/delete)</p>
<h4 id="初始化容器"><a href="#初始化容器" class="headerlink" title="初始化容器"></a>初始化容器</h4><ul>
<li>初始值列表构造函数(initializer-list constructor): 使用元素列表进行初始化</li>
<li><p>push_back(): 类似函数</p>
<p>  class Container {<br>  public:</p>
<pre><code>Container(std::initializer_list&lt;double&gt;); // 使用一个double值列表进行初始化。
void push_back(double); //在末尾添加一个元素，容器长度 +1
</code></pre><p>  };</p>
</li>
</ul>
<p>std::initializer_list是一种标准库类型，编译器可以辨识它：<br>** 当我们使用 {} 列表的时候，如 {1,2,3,4}，编译器就会创建一个initializer_list类型的对象并将其提供给程序。</p>
<p>Container::Container(std::initializer_list<double> lst)<br>  :elem_(new double[lst.size], sz(static_cast<int>(lst.size)))<br>{<br>  std::copy(lst.begin(), lst.end(), elem);<br>}</int></double></p>
<h3 id="抽象类型-接口类型-含有纯虚函数的类，称为抽象类"><a href="#抽象类型-接口类型-含有纯虚函数的类，称为抽象类" class="headerlink" title="抽象类型(接口类型) 含有纯虚函数的类，称为抽象类"></a>抽象类型(接口类型) 含有纯虚函数的类，称为抽象类</h3><p>Container类型之所以被称为具体类型，是因为他们的实现属于定义的一部分。在这点上与内置类型相似。<br>抽象类型则把使用者与类的实现细节完全隔离出来：</p>
<pre><code>class Container {
public:
  virtual double&amp; operator[](int) = 0; // 纯虚函数
  virtual int size() const = 0; // 常量成员函数
  virtual ~Container() {}    //析构函数
};
</code></pre><blockquote>
<p>因为我们对抽象类型一无所知，所以必须从 heap 上位对象分配空间，然后通过引用或指针访问对象。<br>上面这个类纯粹是个接口。关键字virtual的意思是 “可能在随后的派生类中被重新定义”。<br>纯虚函数意味着Container的派生类必须定义这个函数，因此不能单纯定义一个Container对象，Container只能作为<br>接口出现，派生类负责具体实现size, operator[]函数，<strong><em> 含有纯虚函数的类称为抽象类 </em></strong></p>
</blockquote>
<ul>
<li>作为一个抽象类，不需要提供构造函数，毕竟它不需要初始化数据和获取资源。</li>
<li>另一方面，抽象类必须有一个virual的析构函数，  因为需要执行派生类的具体析构函数来释放资源。</li>
</ul>
<h3 id="类层次结构"><a href="#类层次结构" class="headerlink" title="类层次结构"></a>类层次结构</h3><p>class 派生类 : 基类 {<br>};</p>
<p>class 子类： 超类 {<br>};</p>
<pre><code>void use(Container &amp;c)
{
  const int sz = c.size();
  for(int i=0; i!=sz; ++i)
    printf(&quot;%f &quot;,c[i]);
}

class Vector : public Container {
public:
  double &amp;operator[](int i){ return v[i]; }
  size_t size(){ return sz_; }
private:
  std::vector;
};

int main(int argc, char *argv[])
{
  Vector v{1,2,3,4,5};
  use(vc);
}
</code></pre><p>灵活性背后唯一不足的是我们只能通过引用或者指针操作对象。</p>
<h4 id="显式覆盖"><a href="#显式覆盖" class="headerlink" title="显式覆盖"></a>显式覆盖</h4><p>如果派生类的某个函数与基类中虚函数的名字和类型都相同，则派生类的版本会覆盖基类中的版本。<br>可以用 override的指令显式的指明一个函数是否覆盖其基类的函数：</p>
<pre><code>void draw() const override;
</code></pre><p>当这个函数找不到其基类可覆盖的函数的时候，就会产生编译错误。</p>
<h4 id="层次结构的益处"><a href="#层次结构的益处" class="headerlink" title="层次结构的益处"></a>层次结构的益处</h4><ul>
<li>接口继承：派生类对象可以用在任何使用基类对象的地方</li>
<li>实现继承：基类负责提供可以简化派生类实现的函数或者数据。</li>
</ul>
<ol>
<li><p>具体类，尤其是表现形式不复杂的类，其行为非常类似于内置类型</p>
<blockquote>
<p>将其定义为局部变量，通过名字访问，随意拷贝  </p>
</blockquote>
</li>
<li><p>层次结构中的类：</p>
<blockquote>
<p>倾向于通过new来分配空间，然后通过指针或者引用访问。</p>
</blockquote>
</li>
</ol>
<h4 id="层次结构漫游："><a href="#层次结构漫游：" class="headerlink" title="层次结构漫游："></a>层次结构漫游：</h4><p>如果基类指针要使用派生类的函数，就必须用dynamic_cast做转换，再检测后使用 </p>
<pre><code>Shape *ps = read_shape(cin);
Smiley *p = dynamic_cast&lt;Smiley*&gt;(ps);
if(p) {
  p.wink();
}
</code></pre><h4 id="避免资源泄漏"><a href="#避免资源泄漏" class="headerlink" title="避免资源泄漏"></a>避免资源泄漏</h4><ul>
<li>应该用unique_ptr来管理，将new的指针存放在unique_ptr里面管理 </li>
</ul>
<h3 id="拷贝和移动"><a href="#拷贝和移动" class="headerlink" title="拷贝和移动"></a>拷贝和移动</h3><p>当设计一个类时候，必须仔细考虑对象是否会被拷贝以及如何拷贝的问题。</p>
<h4 id="拷贝容器"><a href="#拷贝容器" class="headerlink" title="拷贝容器"></a>拷贝容器</h4><p>默认的 拷贝构造 和 拷贝赋值，都是按照每个类成员的值拷贝的。这种拷贝方式将违反资源句柄的不变式</p>
<p>类对象的拷贝，如果不想使用默认的每个成员的值拷贝，就必须要自定义 <strong> 拷贝构造函数 </strong> 与 <strong> 拷贝赋值运算符 </strong></p>
<pre><code>class Vector {
public:
  // 默认构造函数
  Vector(std::initializer_list&lt;double&gt; lst): 
    sz_(lst.size()),
    ary_(new doulbe[sz_])
  {

  }

  ~Vector(){
    delete[] ary_;
    sz_ = 0;
  }

  // 拷贝构造函数
  Vector(const Vector &amp;v) { 
    sz_ = v.sz_;  
    ary_ = new double[sz_];
    std::copy(ary_, ary_+sz_, v.ary_);
  }

  // 拷贝赋值运算符
  void operator=(const Vector &amp;v) {
    sz_ = v.sz_;  
    ary_ = new double[sz_];
    std::copy(ary_, ary_+sz_, v.ary_);
  }

  size_t size() {
    return sz_;
  }

priavate:
  double *ary_;
  size_ sz_;
};
</code></pre><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>构造函数，析构函数，拷贝操作，移动操作 在逻辑上有千丝万缕的联系，在定义这些函数时我们必须考虑这种内在的<br>联系，否则就会遇到逻辑问题或者性能问题。</p>
<blockquote>
<p>如果类X的析构函数执行了某些特定的任务，比如释放自 heap空间或者释放锁，则该类也应该实现所有的其他相关函数：</p>
</blockquote>
<pre><code>class X {
  X(Sometype); // 普通构造函数
  X(); // 默认构造函数
  X(const X&amp;); // 拷贝构造函数
  X(X &amp;&amp;); // 移动构造函数
  X&amp; operator=(const X&amp;); // 赋值拷贝运算符，清空目标对象并拷贝
  X&amp; operator=(X &amp;&amp;); // 移动赋值运算符，清空目标对象并移动
  ~X();  // 析构函数，清空资源
</code></pre><p>编译器会根据需要生成上面的成员函数(普通构造函数除外)。 如果程序员希望显式使用函数的默认实现</p>
<p>下面5中情况下，对象会被移动或拷贝</p>
<ul>
<li><p>被赋值给其他对象： </p>
<p>  Vector a({1,2,3});<br>  Vector b({4,5,6);<br>  a = b; // 赋值拷贝运算符</p>
</li>
<li><p>作为对象初始值：</p>
<p>  Vector a({1,2,3});<br>  Vector b(a); // 拷贝构造函数</p>
</li>
<li><p>作为函数实参：</p>
<p>  void show(Vector v) {</p>
<p>  }</p>
</li>
</ul>
<h4 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h4><p>广义的资源：</p>
<blockquote>
<p>任何具有  获取 -&gt; 使用 -&gt; 释放 模式的东西，都可以称为资源。<br>例如 内存，锁，套接字，文件句柄，线程句柄 都可以算为资源。同时任何无法同时使用的硬件，也能抽象为资源。</p>
</blockquote>
<p>通过 move，移动构造运算符，移动赋值运算符，unique_ptr  </p>
<h4 id="抑制操作"><a href="#抑制操作" class="headerlink" title="抑制操作"></a>抑制操作</h4><p>处于层次结构的类，使用默认的拷贝或者移动操作常常意味着风险：因为基类指针是无法了解派生类有什么成员。<br>因此最好是删除了默认的拷贝和移动操作：</p>
<pre><code>class Shape {
public:
  Shape(const Shape &amp;) = delete;
  Shape &amp;operator=(const Shape&amp;) = delete;

  Shape(Shape &amp;&amp;) = delete;
  Shape&amp; operator=(Shape &amp;&amp;) = delete;
</code></pre><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>模板：用一组类型或值，对其进行参数化的一个类或者一个函数。</p>
</blockquote>
<p>一个模板及模板参数的集合，被称为实例化。<br><strong> 每个程序使用的实例化代码，是在编译后期，也就是实例化期才产生的 </strong></p>
<pre><code>template&lt;typename T&gt;
class Vector {
public:
  Vecotr(const std::initializer_list&lt;T&gt; &amp;lst):
        sz_(lst.size()),
        ary_(new T[lst.size()])
  {
    int i = 0;
    for(auto &amp;m:lst) {
      ary_[i] = m;
      ++ i;
    }
  }

  Vector(const Vector &amp;v):
        sz_(v.sz_),
        ary_(new T[v.sz_]
  {
    int i = 0;
    for(const T &amp;m:v) {
      ary_[i] = m;
    }
    ++ i;
  }
  ~Vector() {
    delete[] ary_;
    sz_ = 0;
  }

private:
  T *ary_;
  size_t sz_;
};
</code></pre><p>value_tupe 和 constexpr，除了类型参数，模板还可以接受普通的值参数，例如下面的N<br>    template<typename t,="" int="" n=""><br>    struct Buffer {<br>      using value_type = T;<br>      constexpr int size() { return N; }<br>      T[N];<br>    }</typename></p>
<h3 id="概念和泛型编程"><a href="#概念和泛型编程" class="headerlink" title="概念和泛型编程"></a>概念和泛型编程</h3><p>模板提供了以下功能：</p>
<ul>
<li>把类型(以及数值 和 模板)作为实参传递而不损失任何信息的能力。这为内联提供了很多便利，现有的实现可利用这点。</li>
<li>延迟类型检查(在实例化时执行)。意味着程序可以把多个上下文的有用信息捏合在一起。</li>
<li>把常量值作为实参传递的能力，也就是提供编译时计算能力。<blockquote>
<p>总而言之，模板为<strong> 编译时计算 </strong> 和 <strong> 类型控制 </strong>提供了强力的辅助支持，是我们可以编写更加简洁高效的代码。</p>
</blockquote>
</li>
</ul>
<h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>模板的一个特殊用途就是函数对象(functor)，我们可以像使用一个函数那样使用对象：<br>例如：</p>
<pre><code>template &lt;typename T&gt;
class LessThan{
public:
    LessThan(const T &amp;v) :
            val(v){
    }
    bool operator()(const T &amp;c) const {
        return (c &lt; val);
    }

private:
    const T val;
};
</code></pre><p>用于指明通用算法的关键操作含义的函数对象 (如lessThan 之于 count())，被称为 策略对象(policy object)又叫<br>(higher order object)</p>
<p>如果觉得将定义和使用分离比较麻烦，可以用lamda表达式：</p>
<pre><code>[&amp;](int a){ return a &lt; x; }
</code></pre><p>[&amp;]: 是一个捕获列表(capture list)，它指明所用的局部变量名字(如x)将通过引用访问，如果我们只希望捕获 x，<br>则可以写成： </p>
<pre><code>[&amp;x](int a){ return a&lt;x; }
</code></pre><pre><code>[=x](int a){ return a &lt; x; }
</code></pre><p>[]: 什么都不捕获</p>
<h3 id="可变参数模板-variadic-template"><a href="#可变参数模板-variadic-template" class="headerlink" title="可变参数模板 (variadic template)"></a>可变参数模板 (variadic template)</h3><p>template<typename t,="" typename...="" tail=""><br>void f(T head, Tail… tail) {<br>  g(head);<br>  f(tail…);<br>}</typename></p>
<blockquote>
<p>省略号… 表示列表的 “剩余部分” 。最终tail会变为空，我们需要另外一个函数处理空：<br>template&lt;&gt;<br>void f(){</p>
</blockquote>
<p>}</p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>很多情况下，我们应该为类型或者模板引入一个同义词。例如<br>using size_t = unsigned int;</p>
<p>实际上，每个标准库容器都提供了value_type作为其值类型的名字，这样我们编写的代码就能在任何一个服从这种规范的<br>容器上工作了：</p>
<pre><code>template&lt;typename C&gt;
using ElementType = typename C::value_type;
</code></pre><p>通过绑定某些或者全部模板实参，我们就能使用别名机制定义新的模板了：</p>
<pre><code>template&lt;typename Key, typename Value&gt;
class Map{
  // ...
};

template&lt;typename Value&gt;
using StringMap = Map&lt;string,Value&gt;

StringMap&lt;int&gt; m; // m是一个 Map&lt;string, int&gt;
</code></pre><h2 id="标准库概览"><a href="#标准库概览" class="headerlink" title="标准库概览"></a>标准库概览</h2><h3 id="标准库组件"><a href="#标准库组件" class="headerlink" title="标准库组件"></a>标准库组件</h3><ul>
<li>运行时语言支持(例如，对资源分配和运行时类型信息的支持)</li>
<li>C标准库</li>
<li>字符串(包括国际字符和本地化的支持)</li>
<li>正则表达式的支持</li>
<li>I/O流，可扩展的输入输出框架，用户可向其中添加自己设计的类型，流，缓冲策略，区域设定和字符集。</li>
<li>容器(std::vector std::map)和算法(std::find, std::sort)</li>
<li>数值计算的支持(标准数学函数，复数，向量及随机数发生器)</li>
<li>并发程序设计支持(thread, mutex, condition)</li>
<li>支持模板元程序设计的工具，STL风格的泛型程序设计(pair)</li>
<li>资源管理的 “智能指针” unique_ptr, shared_ptr, weak_ptr</li>
<li>特殊用途容器 如 array,bitset,tuple<br>本质上，C++标准库提供了最常用的基本数据结构及其上的基础算法</li>
</ul>
<pre><code>&lt;array&gt;         array
&lt;chrono&gt;        duration, time_point
&lt;cmath&gt;         sqrt(), pow()
&lt;complex&gt;       complex, sqrt(), pow()
&lt;forward_list&gt;  forward_list
&lt;fstream&gt;       fstream, ifstream, ofstream
&lt;future&gt;        future, promise
&lt;ios&gt;           hex, dec, scientific, fixed, defaultfloat
&lt;iostream&gt;      istream, ostream, cin, cout
&lt;map&gt;           map, multimap
&lt;memory&gt;        unique_ptr, shared_ptr, weak_ptr, allocator
&lt;random&gt;        default_random_engine, normal_distribution
&lt;regex&gt;         regex, smatch
&lt;string&gt;        string, basic_string
&lt;set&gt;           set, multiset
&lt;sstream&gt;       istrstream, ostrstream
&lt;stdexcept&gt;     length_error, out_of_range, runtime_error
&lt;thread&gt;        thread
&lt;unordered_map&gt; unordered_map, unordered_multimap
&lt;utility&gt;       move(), swap(), pair
&lt;vector&gt;        vector
</code></pre><p>来自C中的标准库头文件，例如 &lt;stdlib.h&gt; ，对应版本为 <cstdlib>。声明都在std::的空间中</cstdlib></p>
<h2 id="字符串和正则表达式"><a href="#字符串和正则表达式" class="headerlink" title="字符串和正则表达式"></a>字符串和正则表达式</h2><p>string类型，比char*提供更完整的字符串处理能力</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>额外的字符串处理能力有：</p>
<ul>
<li>连接(concat):  “+”</li>
<li>下表操作:  “[] 或 at()”</li>
<li>替换字符串内容: “replace()”</li>
<li>C风格字符串(以0结尾的char数组): c_str()</li>
</ul>
<h3 id="string的实现"><a href="#string的实现" class="headerlink" title="string的实现"></a>string的实现</h3><p>为了处理多字符集，标准库定义了一个通用的字符串模板 basic_string， string 实际上是此模板的char实例化的一个别名。</p>
<pre><code>template&lt;typename Char&gt;
class basic_string {
  // ... Char类型的字符串
}
using string = basic_string&lt;char&gt;
</code></pre><p>用户可以定义任意类型的字符串，例如日文字符类型：Jchar:</p>
<pre><code>using Jstring = basic_string&lt;Jchar&gt;;
</code></pre><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><pre><code>regex pat (R&quot;(\w{2}\s*\d{5}(-\d{4})?)&quot;); // 美国邮政编码模式: XXddddd-dddd 及其变形
</code></pre><p>原始字符串字面值常量(raw string literal)，其以 -R”” 包括，原始字符串字面量值常量好处式：<br>可以直接包含反斜线 \ 和 “” 而无需转义</p>
<p><regex>中，正则表达式提供了如下支持：</regex></p>
<ul>
<li>regex_match()：将正则表达式与一个(已知长度的)字符串进行匹配。</li>
<li>regex_search()：在一个(任意长的)的数据流中搜索与正则表达式匹配的字符串。</li>
<li>regex_replace()：在一个(任意长的)数据流中搜索与正则表达式匹配的字符串并将其替换。</li>
<li>regex_iterator：遍历匹配结果和子匹配。</li>
<li>regex_token_iterator：遍历未匹配部分。</li>
</ul>
<h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><pre><code>int lineno = 0;
for(string line; getline(cin,line);) {
  ++lineno;
  smatch matches;
  if(regex_search(line, matches, pat))
    cout &lt;&lt; lineno &lt;&lt; &quot;:&quot; &lt;&lt; matches[0] &lt;&lt; &apos;\n&apos;;
}
</code></pre><p>regex_search(line, matches, pat) 在line中搜索任何与正则表达式pat 匹配的子串，如果匹配到，就保存在matches中<br>如果没有任何匹配，就返回false。<br>smatch matches： smatch实际上是一个string的vector，每个string 保存的是一个子匹配。</p>
<pre><code>.   任意单个字符(&quot;通配符&quot;)
[   字符集开始
]   字符集结束
{   指定重复次数开始
}   指定重复次数结束
(   分组开始
)   分组结束

\   下一个字符有特殊含义
*   零或多次重复(后缀操作)
+   一或多次重复(后缀操作)
?   可选(零或一次)(后缀操作)
|   二选一 (或)
^   行开始; 非
$   行结束

{n}      严格重复n次         (times == n)
{n,}     重复n次或更多次     ( times &gt;= n )
{n,m}    至少重复n次，最多m次 ( times &gt;= n , times &lt;= m )
*        重复0次或多次(任意次数)
+        重复 1次或者多次  (&gt;= 1)
?        重复0，或者一次  ( times == 0 || times == 1 )
</code></pre><p>匹配模式总是查找最长匹配，这就是所谓的<strong> 最长匹配法则 </strong> ， 但是如果在任何重复符号后面放一个?后缀，会使匹配<br>器变得”懒惰，不贪心”，而是查找最短匹配。</p>
<pre><code>例如：(ab)* 和 (ab)*?
regex pat{R&quot;(ab)*&quot;};
regex_search(string(&quot;ababababab&quot;, matches, pat));
</code></pre><p>＾放在集合［］的开头，表示非，其他位置则表示普通的 ^ 字符</p>
<pre><code>例如:
 [^aeiouy] : 匹配非元音字符 (b,c,d ...)
 [a^eiouy] : 配合元音字符或 ^ 字符
</code></pre><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>regex_iterator遍历一个流(字符序列)</p>
<h2 id="I-O-流"><a href="#I-O-流" class="headerlink" title="I/O 流"></a>I/O 流</h2><p>I/O 流库提供了文本和数值的输入输出功能，这种输入输出是带缓冲的，可以是格式化，也可以是未格式化的。</p>
<ul>
<li>在<ostream>中，I/O流库为所有的<strong> 内置类型 </strong>都定义了输出操作</ostream></li>
<li>用户自定义类型定义输出操作也很简单，只需要重载 输出运算符 “ &lt;&lt; “ 即可。</li>
</ul>
<p>ostream 对象将有类型的对象转换为一个字符(字节)流：</p>
<pre><code>&apos;c&apos;, 123, (123,45) --&gt; ostream --&gt; stream buffer --&gt; 字节序列

cout &lt;&lt; 1; // 将整数转换为字符串，同时输出到stdout
</code></pre><p>istream 对象将一个字符(字节) 流转换为有类型的对象</p>
<p>字节序列 –&gt; stream buffer –&gt; istream –&gt; ‘c’, 123, (123, 45)</p>
<pre><code>int val;
cin &gt;&gt; val; // 将stdin输入的字节序列转换为int 值
</code></pre><p>getline()函数来读取一整行，同时<strong> getline会将行尾的换行符丢掉 </strong></p>
<h3 id="I-O-状态"><a href="#I-O-状态" class="headerlink" title="I/O 状态"></a>I/O 状态</h3><p>每个iostream都有状态，此状态可用来判断流操作是否成功。</p>
<pre><code>istream &amp;is;
is &gt;&gt; c; // is &gt;&gt; c 会跳过空白符，而 is.get() 不会
</code></pre><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><pre><code>constexpr double d = 123.456;
cout &lt;&lt; d &lt;&lt; &quot;;&quot;                    // 123.456
     &lt;&lt; scientific &lt;&lt; d &lt;&lt; &quot;;&quot;      // 1.1234560e2+002;
     &lt;&lt; hexfloat &lt;&lt; d &lt;&lt; &quot;;&quot;        // 0x1.edd2f2p+6
     &lt;&lt; fixed &lt;&lt; d &lt;&lt; &quot;;&quot;           // 123.456
     &lt;&lt; defaultfloat &lt;&lt; d &lt;&lt; &apos;\n&apos;;  //默认格式输出 d
</code></pre><h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><p>在<fstream>中，标准库提供了从文件读取数据及向文件写入数据的流</fstream></p>
<ul>
<li>ifstream 从文件读取数据</li>
<li>ofstream 向文件写入数据</li>
<li>fstream  读写文件</li>
</ul>
<pre><code>ofstream ofs(&quot;target&quot;);
if(!ofs)
  error(&quot;could&apos;t open &apos;target&apos; for writing&quot;);

ifstream ifs(&quot;source&quot;);
if(!ifs)
  error(&quot;could&apos;t open &apos;source&apos; for writing&quot;);
假定检测成功， ofs就可以像普通ostream一样使用(就像cout), ifs就像普通istream一样使用
</code></pre><h3 id="字符串流"><a href="#字符串流" class="headerlink" title="字符串流"></a>字符串流</h3><p><sstream> 标准库提供了从string读取数据，以及向string写入数据的流:</sstream></p>
<ul>
<li>istringstream ：从string读取数据</li>
<li>ostringstream ：向string写入数据</li>
<li>stringstream： 读写string</li>
</ul>
<p>istringstream中的内容可以通过 str() 函数来获取。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector 就是最常用的容器</p>
<h3 id="范围检查"><a href="#范围检查" class="headerlink" title="范围检查"></a>范围检查</h3><p>标准库vector的小标操作符 [] 并不进行范围检查，而at() 有范围检查，例如：</p>
<pre><code>vector&lt;int&gt; book(4) = {0,1,2,3};
boot.size();// 4
book[size()]; // 越界访问
</code></pre><p>at() 会在参数越界时候抛出一个类型为out_of_range的异常</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list是标准库提供的一个双向链表，如果需要在一个序列中添加，删除元素而无需移动其他元素，则应该使用list  </p>
<ul>
<li>对于存在着频繁插入，删除操作的功能，应该用list更为适合。</li>
</ul>
<h3 id="begin-end-迭代器，需要在标准库容器中定位，增添，删除一个元素，就必须使用到迭代器了。"><a href="#begin-end-迭代器，需要在标准库容器中定位，增添，删除一个元素，就必须使用到迭代器了。" class="headerlink" title="begin(), end() 迭代器，需要在标准库容器中定位，增添，删除一个元素，就必须使用到迭代器了。"></a>begin(), end() 迭代器，需要在标准库容器中定位，增添，删除一个元素，就必须使用到迭代器了。</h3><blockquote>
<p>当数据量较小的时候，vector的性能会优于list。当我们想要不过是一个元素序列的时候，就应该在vector和list<br>之间选择，除非有充分理由选择list，否则就应该使用vector<br>vector无论在遍历( find(), count()) 还是排序和搜索( sort(), binary_searh())性能都要优于list</p>
</blockquote>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map搜索树(红黑树), map也被称为关联数组或字典。map通常用平衡二叉树实现。<br>对map进行下标操作的本质是进行一次搜索，如果未找到key，则自动向map插入一个新元素，它具有给定的key，关联的值<br>是value类型的默认值。  </p>
<p>因此为了避免自动增添默认值，就应该使用find()和insert()</p>
<h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p>标准哈希容器被称为 “无序” 容器。<br>标准库为 内置类型(int,float,char …) 和 标准库类型(vector, string…) 提供了默认的哈希函数。<br>必要时你可以定义自己的哈希函数，哈希函数通常以函数对象的形式提供：</p>
<p>标准库的各种容器及它们的基本操作都被设计成相似的，而且不同容器，操作的含义也是相同的。基本操作可用于每一种适用<br>的容器，且可高效实现</p>
<ul>
<li>begin()返回首元素和end()返回末尾元素(末尾元素位置 + 1)</li>
<li>push_back()，高效的在容器末尾添加元素</li>
<li>size() 返回元素数目</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>单纯一个数据结构时没有太大用处的，除了必须的添加，删除简单操作，还需要对他们进行排序，打印，抽取子集，搜索<br>删除元素，等更复杂的操作。</p>
<p>标准库除了提供常用的容器外，还提供了常用的算法： sort, unique_copy 等</p>
<blockquote>
<p>标准库算法都描述为元素(半开)序列上的操作。<br>序列(sequence)由一对迭代器表示，<strong> 分别指向首元素和尾后位置 </strong></p>
</blockquote>
<h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>当拿到一个容器，便可获得一些重要元素的迭代器： begin(), end()。另外很多算法都是返回迭代器，例如find()</p>
<p>很多标准搜索算法，find()返回 end()表示”未找到”。 </p>
<p>迭代器的重要作用时分离算法和容器(数据结构)。算法通过迭代器来处理数据，而算法对存储元素的容器一无所知。<br>容器也对算法一无所知，容器只需要按照需求提供迭代器(如 begin() 和 end())</p>
<h3 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h3><p>每个迭代器都是与某个特定容器类型相关联的。因此由多少种容器就有多少种迭代器</p>
<p>所有迭代器的语义及操作的命名都是类似的：<br>例如：</p>
<ul>
<li>任何迭代器使用 ++ 运算，都会得到指向下一个元素的迭代器。</li>
<li>*运算都会得到迭代器所指向的元素</li>
</ul>
<h3 id="流迭代器"><a href="#流迭代器" class="headerlink" title="流迭代器"></a>流迭代器</h3><p>迭代器的概念除了用于处理容器元素序列，还用于 输入输出流。<br>可以创建一个ostream_iterator 迭代器来处理输出流。我们需要指出使用哪个流，以及输出对象类型。</p>
<pre><code>例如：
ostream_iterator&lt;string&gt; oo{count}; //将字符串写入 cout

这样，向*oo 赋值就会将值打印到cout
int main() {
  *oo = &quot;hello&quot;;
  oo ++;
  *oo = &quot; world!\n&quot;;
}
</code></pre><p>类似，istream_iterator 允许我们将一个输入流作为一个只读容器来处理：</p>
<pre><code>istream_iterator&lt;string&gt; ii{cin};
与所有迭代器类似，需要一对输入迭代器来表示一个序列(begin()和end())。
</code></pre><h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><pre><code>auto p = find_if(m.begin(), m.end(), [](const pair&lt;string, int&gt;&amp; r){ return r.second &gt; 42; };
</code></pre><h3 id="标准库的算法概览"><a href="#标准库的算法概览" class="headerlink" title="标准库的算法概览"></a>标准库的算法概览</h3><blockquote>
<p>C++的标准库的语境中，算法就是一个对元素序列进行操作的函数模板。 </p>
</blockquote>
<p>标准库提供了很多算法，都在std::的命名空间中，通过<algorithm>提供。这些标准库算法都以序列作为输入。[begin(),end())</algorithm></p>
<pre><code>p = find(b, e, x);  // p是[b:e)中第一个满足 *p == x的迭代器
p = find_if(b,e,f)  // p是[b:e)中第一个满足f(*p) == true的迭代器
n = count(b,e,x);   // n是[b:e)中满足*q == x的元素 *q 的数目
n = count(b,e,f);
replace(b,e,v,v2);  //将[b:e)中满足 *q == v的元素 *q替换为v2
replace_if(b,e,f,v2); //
p = copy(b,e,out); //将[b:e)拷贝到 [out,p)
p = copy_if(b,e,out,f);
p = move(b,e,out); //将[b:e) 移动到 [out:p)
p = unique_copy(b,e,out,f); // 将[b:e)拷贝到[out:p)，不拷贝连续的重复元素
sort(b,e); // 排序[b:e)中的元素，用 &lt; 作为排序标准
sort(b,e,f); //排序[b:e)中的元素，用谓词f作为排序标准
(p1,p2) = equal_range(b,e,v); //[p1:p2)是已经排序序列[b:e)的子序列，其中的元素值都
p = merge(b,e,b2,e2,out);  // 将两个序列[b:e) 和 [b2:e2)合并，结果保存到[out:p)
</code></pre><p>一些算法会修改元素的值，但是没有算法会在容器中添加或删除元素，原因在于序列中并不包含底层容器的信息。<br>如果需要添加元素，就需要使用了解容器信息的函数：如 back_inserter，或者直接访问容器本身，如push_back()或erase()</p>
<h3 id="容器算法"><a href="#容器算法" class="headerlink" title="容器算法"></a>容器算法</h3><h2 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h2><h3 id="资源管理-1"><a href="#资源管理-1" class="headerlink" title="资源管理"></a>资源管理</h3><blockquote>
<p>资源，就是指程序中符合<strong> 先获取，再使用，后释放 </strong> 规律的东西。<br>RAII 是C++处理资源的基础，容器(vector,map), string, iostream管理资源(文件句柄和缓冲区)的方式是类似的。</p>
</blockquote>
<h4 id="unique-ptr-和-shared-ptr"><a href="#unique-ptr-和-shared-ptr" class="headerlink" title="unique_ptr 和 shared_ptr"></a>unique_ptr 和 shared_ptr</h4><p>定义在作用域上的对象，作用域结束的时候会自动释放资源。<br>如果对象是在 heap 上分配的，标准库提供了 unique_ptr 和 shared_ptr 两个”智能指针” 工具，将heap 分配的资源<br>和域作用域上分配的资源绑定起来，实现自动释放的功能。</p>
<ol>
<li>unique_ptr 对应所有权唯一的情况。</li>
<li>shared_ptr 对应共享所有权的情况。</li>
</ol>
<p>在什么情况下我们应该选择”只能指针” ，而不是带有特定操作的资源句柄(比如 vector 和 thread)?</p>
<blockquote>
<p>答案是：”当我们需要使用指针的语义时候”</p>
<ol>
<li>当我们共享某个对象，需要让多个指针或者引用指向共享对象，此时选择shared_ptr</li>
<li>当我们使用一个多态对象，很难确切知道对象是什么类型，此时unique_ptr称为必然选择</li>
<li>共享的多态对象通常会用到shared_ptr</li>
</ol>
</blockquote>
<h4 id="特殊容器"><a href="#特殊容器" class="headerlink" title="特殊容器"></a>特殊容器</h4><pre><code>T[N]：           内置数组
arrary&lt;T,N&gt;      是一段尺寸固定且连续分配的序列，包含N个T类型的元素;与内置数组类似，但是解决了很多问题。
bitset&lt;N&gt;        一段固定大小的序列，包含N位
vector&lt;bool&gt;     一段位的序列，紧密存储在一个特殊的vector 中
pair&lt;T,U&gt;        两个元素，分别类型为T和U
tuple&lt;T...&gt;      一段序列，存放着任意类型的元素，元素个数任意
basic_string&lt;C&gt;  一段字符序列，字符类型是C; 提供字符串操作。
valarray&lt;T&gt;      一个数组，包含T类型的数值;提供数值操作。
</code></pre><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><p><array> 中的 array 表示一个<strong> 尺寸固定 </strong> 的元素序列，元素个数在编译时指定。<br>因此array的元素可以位于栈中或者对象内，也可以位于静态存储空间。元素所属的作用域就是array的作用域<br>array 不会自动转换为指针，比内置数组更加安全：</array></p>
<pre><code>Circle a1[10];
array&lt;Circle, 10&gt; a2;
Shape *p1 = a1; // 语法上正确，但是存在严重隐患
Shape *p2 = a2; // 报告 语法错误，无法编译通过
p1[3].draw(); // 程序错误 (因为 sizeof(Shape) &lt; sizeof(Circle)，导致 p[3] 的时候会出现错误偏移量。
</code></pre><h4 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h4><p>各种位运算，以及左移和右移都可能用在bitset上</p>
<pre><code>bitset&lt;9&gt; bs3 = ~bs1;
</code></pre><h4 id="pair-和-tuple"><a href="#pair-和-tuple" class="headerlink" title="pair 和 tuple"></a>pair 和 tuple</h4><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><pre><code>#include &lt;chrono&gt;
auto t0 = high_resolution_clock::now();
do_work();
auto t1 = high_resolution_clock::now();
cout &lt;&lt; duration_cast&lt;milliseconds&gt;(t1-t0).count() &lt;&lt; &quot; ms\n&quot;;
</code></pre><h4 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h4><p>函数适配器接受一个函数作为它的参数，返回的结果是一个函数对象，我们可以使用这个函数对象调用原来的函数。</p>
<p>bind() 和 mem_fn 适配器绑定参数。</p>
<p>mem_fn函数适配器生成一个函数对象，我们能够调用非成员函数一样调用这个函数对象：</p>
<pre><code>void user(Shape *p)
{
  p-&gt;draw();
  auto draw = mem_fn(&amp;Shape::draw);
  draw(p);
}

void draw_all(vector&lt;Shape*&gt; &amp;v) {
  for_each(v.begin(), v.end(), mem_fn(&amp;Shape::draw));
}

void draw_all(vector&lt;Shape*&gt; &amp;v) {
  for_each(v.begin(), v.end(), [](Shape* s){ s-&gt;draw(); });
}
</code></pre><h4 id="function"><a href="#function" class="headerlink" title="function"></a>function</h4><p>标准库 function 是一种数据类型，它可以存放任意对象，只要该对象能用运算符()调用。也就是说：<br><strong> 类型 function 的对象是一个函数对象 </strong> </p>
<h3 id="类型函数"><a href="#类型函数" class="headerlink" title="类型函数"></a>类型函数</h3><p>类型函数(type function)是指<strong> 在编译期求值的函数 </strong>，它接受要给类型作为实参或者返回一个类型作为结果。标准库提供了大量的类型函数。</p>
<p>constexpr float min = numeric_limits<float>::min();<br>sizeof() 其实也是一个类型函数。</float></p>
<blockquote>
<p>类型函数是C++编译期计算机制的一部分，它允许程序进行轻量级类型检查以获取更优的性能。<br>我们通常把这种用法称为 <strong> 元编程 </strong> (meta programming)</p>
</blockquote>
<blockquote>
<p>当含有模板时称为 <strong> 模板元编程 </strong> (template metaprogramming)</p>
</blockquote>
<h4 id="iterator-traits"><a href="#iterator-traits" class="headerlink" title="iterator_traits"></a>iterator_traits</h4><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="任务和thread"><a href="#任务和thread" class="headerlink" title="任务和thread"></a>任务和thread</h3><p>将与其他计算并行执行的计算，成为任务(task)。线程(thread)是任务在程序中的系统级表示。<br>若要启动一个与其他任务并发执行的任务，可构造一个std::thread，将任务作为他的参数，任务以函数或函数对象的形式实现</p>
<pre><code>// 函数
void f(); 

//函数对象    
struct F{
  void operator(){};
};

void user() {
  thread t1{f};
  thread t2 {F()};

  t1.join(); //等待t1完成
  t2.join(); //等待t2完成
}
</code></pre><p> 由于两个任务(线程)是共享一个地址空间，因此两个线程间可共享数据。<br> 在定义一个并发程序的时候，我们的目标是保持任务的完全隔离，唯一例外是任务见通信的部分。<br> 考虑一个并发任务的最简单方式是将它看作一个可以与调用者并发执行的函数。为此我们只需传递参数，获取结果并保证<br> 两者不同时使用共享数据。</p>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>任务通常要处理数据，我们将数据(或指向数据的指针或引用)作为参数传递给任务：</p>
<pre><code>void f(vector&lt;double&gt;&amp; v);
struct F {
  vector&lt;double&gt;&amp; v;
  F(vector&lt;double&gt;&amp; vv): v(vv){};
  void operator(){};
};

int main(){
  vector&lt;double&gt; v1 = {1,2,3,4};
  vector&lt;double&gt; v2 = {9,8,7,6};
  thread t1{f, ref(v1)}; // f(v1) 在一个独立的线程中执行
  thread t2{F(v2)}; // f(v2) 在一个独立的线程中执行
}
</code></pre><p>thread t1{f, ref(v1)}; // 这里使用了thread的可变参数模板构造函数，它接受一个任意的参数序列<br>我们必须使用ref()来告诉可变参数模板将v2作为一个引用而不是一个对象来处理。</p>
<h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><p>将输入数据以const引用方式传递，并将保存结果的内存地址作为第二个参数传递给线程</p>
<pre><code>void f(const vector &amp;v, double *res){};
struct F {
  F(const vector &amp;vv, double *d):
        v(vv),
        res(d){
  }
  void operator()(){};
};

int main(){
  vector&lt;double&gt; v1 = {1,2,3,4};
  vector&lt;double&gt; v2 = {9,8,7,6};
  double res1;
  double res2;
  thread t1{f, cref(v1), &amp;res1);
  thread t2{F(v2, &amp;res2)};

  t1.join();
  t2.join();
};
</code></pre><h3 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h3><p>互斥对象： mutex</p>
<pre><code>mutex m;
int sh;
void f() {
  unique_lock&lt;mutex&gt; lck{m};
  sh += 7;
} // 隐式释放mutex
</code></pre><p>unique_lock的构造函数获取了互斥对象(通过调用 m.lock())。</p>
<p>共享数据和mutex间是一种常规的对应关系：程序员必须知道那个mutex对应哪个数据，显然这容易出错，我们应该借助<br>多种语言特性来使这种关系更为清晰：</p>
<pre><code>class Record{
public:
    mutex rm;
};
</code></pre><p>通过共享数据进行通讯是一种很底层的方式。特别是程序员必须想方设法了解各种任务已经执行那些工作，及尚未执行那些工作。<br>在这方面共享数据不如调用-返回模式。</p>
<pre><code>class Message {
  Message(string&amp; m):
    msg(m){};

private:
  string msg;
};
queue&lt;Message&gt; msgQueue;
mutex msgMutex;
condition_variable msgCond;

void consumer() {
  unique_lock&lt;mutex&gt; lck(msgMutex);
  while(msgCond.wait(lck)){};
  auto m = msgQueue.front();
  msgQueue.pop();
  lck.unlock();
}

void producer() {
  auto m = new Message(&quot;hello world\n&quot;);
  unique_lock&lt;mutex&gt; lck(msgMutex);
  msgQueue.push_back(m);
  msgCond.notify_one();
}
</code></pre><h3 id="任务通讯"><a href="#任务通讯" class="headerlink" title="任务通讯"></a>任务通讯</h3><p>标准库提供了一些特性，允许程序员在抽象的任务层(工作并执行)进行操作，而不是在底层的线程和锁的层次直接进行操作</p>
<p><future></future></p>
<ol>
<li>future 和 promise 用来从一个独立线程上创建出的任务返回值。</li>
<li>package_task 是帮助启动任务以及连接返回结果的机制。</li>
<li>async() 以类似调用函数的方式启动一个任务。</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/firefirer.github.io/2018/05/19/template-can-do-what/" rel="next" title="What Can Template Do ?">
                <i class="fa fa-chevron-left"></i> What Can Template Do ?
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/firefirer.github.io/2018/05/31/muduo-source-read/" rel="prev" title="Muduo Source Read">
                Muduo Source Read <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Fyman.zhang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/firefirer.github.io/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/firefirer.github.io/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#A-Tour-in-C"><span class="nav-number">1.</span> <span class="nav-text">A Tour in C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本知识"><span class="nav-number">1.1.</span> <span class="nav-text">基本知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#声明，类型，对象，变量，值"><span class="nav-number">1.1.1.</span> <span class="nav-text">声明，类型，对象，变量，值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量初始化"><span class="nav-number">1.1.2.</span> <span class="nav-text">变量初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域和生命周期："><span class="nav-number">1.1.3.</span> <span class="nav-text">作用域和生命周期：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量"><span class="nav-number">1.1.4.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针，数组，引用"><span class="nav-number">1.1.5.</span> <span class="nav-text">指针，数组，引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户自定义类型"><span class="nav-number">1.2.</span> <span class="nav-text">用户自定义类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内置类型"><span class="nav-number">1.2.1.</span> <span class="nav-text">内置类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义类型"><span class="nav-number">1.2.2.</span> <span class="nav-text">自定义类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-delete-操作符"><span class="nav-number">1.2.3.</span> <span class="nav-text">new / delete 操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义类型-struct-class-enum-union"><span class="nav-number">1.2.4.</span> <span class="nav-text">自定义类型 : struct/class , enum, union</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类-class-struct-："><span class="nav-number">1.2.4.1.</span> <span class="nav-text">类 class/struct  ：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#联合-union"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">联合 union</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#枚举-enum"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">枚举 enum</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块化"><span class="nav-number">1.3.</span> <span class="nav-text">模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引言"><span class="nav-number">1.3.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分离编译"><span class="nav-number">1.3.2.</span> <span class="nav-text">分离编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名空间"><span class="nav-number">1.3.3.</span> <span class="nav-text">命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误处理"><span class="nav-number">1.3.4.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#异常-exception"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">异常(exception)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态断言"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">静态断言</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类"><span class="nav-number">1.4.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#具体类："><span class="nav-number">1.4.1.</span> <span class="nav-text">具体类：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#容器：是指一个包含若干元素的对象。"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">容器：是指一个包含若干元素的对象。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化容器"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">初始化容器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类型-接口类型-含有纯虚函数的类，称为抽象类"><span class="nav-number">1.4.2.</span> <span class="nav-text">抽象类型(接口类型) 含有纯虚函数的类，称为抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类层次结构"><span class="nav-number">1.4.3.</span> <span class="nav-text">类层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#显式覆盖"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">显式覆盖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#层次结构的益处"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">层次结构的益处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#层次结构漫游："><span class="nav-number">1.4.3.3.</span> <span class="nav-text">层次结构漫游：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#避免资源泄漏"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">避免资源泄漏</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拷贝和移动"><span class="nav-number">1.4.4.</span> <span class="nav-text">拷贝和移动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#拷贝容器"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">拷贝容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本操作"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#资源管理"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">资源管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抑制操作"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">抑制操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板"><span class="nav-number">1.5.</span> <span class="nav-text">模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引言-1"><span class="nav-number">1.5.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念和泛型编程"><span class="nav-number">1.5.2.</span> <span class="nav-text">概念和泛型编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数对象"><span class="nav-number">1.5.3.</span> <span class="nav-text">函数对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变参数模板-variadic-template"><span class="nav-number">1.5.4.</span> <span class="nav-text">可变参数模板 (variadic template)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#别名"><span class="nav-number">1.5.5.</span> <span class="nav-text">别名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准库概览"><span class="nav-number">1.6.</span> <span class="nav-text">标准库概览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标准库组件"><span class="nav-number">1.6.1.</span> <span class="nav-text">标准库组件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串和正则表达式"><span class="nav-number">1.7.</span> <span class="nav-text">字符串和正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串"><span class="nav-number">1.7.1.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string的实现"><span class="nav-number">1.7.2.</span> <span class="nav-text">string的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正则表达式"><span class="nav-number">1.7.3.</span> <span class="nav-text">正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#搜索"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">搜索</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器"><span class="nav-number">1.7.4.</span> <span class="nav-text">迭代器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O-流"><span class="nav-number">1.8.</span> <span class="nav-text">I/O 流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O-状态"><span class="nav-number">1.8.1.</span> <span class="nav-text">I/O 状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#格式化"><span class="nav-number">1.8.2.</span> <span class="nav-text">格式化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件流"><span class="nav-number">1.8.3.</span> <span class="nav-text">文件流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串流"><span class="nav-number">1.8.4.</span> <span class="nav-text">字符串流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器"><span class="nav-number">1.9.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-number">1.9.1.</span> <span class="nav-text">vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#范围检查"><span class="nav-number">1.9.2.</span> <span class="nav-text">范围检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list"><span class="nav-number">1.9.3.</span> <span class="nav-text">list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#begin-end-迭代器，需要在标准库容器中定位，增添，删除一个元素，就必须使用到迭代器了。"><span class="nav-number">1.9.4.</span> <span class="nav-text">begin(), end() 迭代器，需要在标准库容器中定位，增添，删除一个元素，就必须使用到迭代器了。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-number">1.9.5.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unordered-map"><span class="nav-number">1.9.6.</span> <span class="nav-text">unordered_map</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法"><span class="nav-number">1.10.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用迭代器"><span class="nav-number">1.10.1.</span> <span class="nav-text">使用迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器类型"><span class="nav-number">1.10.2.</span> <span class="nav-text">迭代器类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流迭代器"><span class="nav-number">1.10.3.</span> <span class="nav-text">流迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#谓词"><span class="nav-number">1.10.4.</span> <span class="nav-text">谓词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标准库的算法概览"><span class="nav-number">1.10.5.</span> <span class="nav-text">标准库的算法概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器算法"><span class="nav-number">1.10.6.</span> <span class="nav-text">容器算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实用工具"><span class="nav-number">1.11.</span> <span class="nav-text">实用工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#资源管理-1"><span class="nav-number">1.11.1.</span> <span class="nav-text">资源管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#unique-ptr-和-shared-ptr"><span class="nav-number">1.11.1.1.</span> <span class="nav-text">unique_ptr 和 shared_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特殊容器"><span class="nav-number">1.11.1.2.</span> <span class="nav-text">特殊容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#array"><span class="nav-number">1.11.1.3.</span> <span class="nav-text">array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bitset"><span class="nav-number">1.11.1.4.</span> <span class="nav-text">bitset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pair-和-tuple"><span class="nav-number">1.11.1.5.</span> <span class="nav-text">pair 和 tuple</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间"><span class="nav-number">1.11.1.6.</span> <span class="nav-text">时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数适配器"><span class="nav-number">1.11.1.7.</span> <span class="nav-text">函数适配器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#function"><span class="nav-number">1.11.1.8.</span> <span class="nav-text">function</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型函数"><span class="nav-number">1.11.2.</span> <span class="nav-text">类型函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#iterator-traits"><span class="nav-number">1.11.2.1.</span> <span class="nav-text">iterator_traits</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发"><span class="nav-number">1.12.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#任务和thread"><span class="nav-number">1.12.1.</span> <span class="nav-text">任务和thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传递参数"><span class="nav-number">1.12.2.</span> <span class="nav-text">传递参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回结果"><span class="nav-number">1.12.3.</span> <span class="nav-text">返回结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享数据"><span class="nav-number">1.12.4.</span> <span class="nav-text">共享数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务通讯"><span class="nav-number">1.12.5.</span> <span class="nav-text">任务通讯</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fyman.zhang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/firefirer.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/firefirer.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/firefirer.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/firefirer.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/firefirer.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/firefirer.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/firefirer.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/firefirer.github.io/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/firefirer.github.io/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/firefirer.github.io/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/firefirer.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
